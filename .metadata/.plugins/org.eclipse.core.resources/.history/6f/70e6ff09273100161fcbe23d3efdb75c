package com.project.my2048;

import java.util.ArrayList;
import java.util.List;

import android.content.Context;
import android.graphics.Point;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.GridLayout;

public class GameView extends GridLayout {
	// 保U期g重三造方法，但是真的不知道，保U在哪Y呀
	public GameView(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);
		// TODO Auto-generated constructor stub
		initGameView();
	}

	public GameView(Context context) {
		super(context);
		// TODO Auto-generated constructor stub
		initGameView();
	}

	public GameView(Context context, AttributeSet attrs) {
		super(context, attrs);
		// TODO Auto-generated constructor stub
		initGameView();
	}

	/**
	 * 不管从哪一个构造 方法中进来都是要执行初始化方法，我们就将初始化方法设定为类的入口。
	 */
	private void initGameView() {
		/**
		 * W@Y是怎N通^O|摸事件M行分析的，要根它的
		 */
		setColumnCount(4);// 直接指明是4列的
		setBackgroundColor(0xffbbada0);// 给整个游戏view上个底色
		setOnTouchListener(new OnTouchListener() {
			private float startX, startY, offsetX, offsetY;

			@Override
			public boolean onTouch(View v, MotionEvent event) {
				// TODO Auto-generated method stub
				switch (event.getAction()) {
				case MotionEvent.ACTION_DOWN:
					startX = event.getX();
					startY = event.getY();
					break;
				case MotionEvent.ACTION_UP:
					offsetX = event.getX() - startX;
					offsetY = event.getY() - startY;
					// @Y要注意的一c是，用粼诨拥r候很有可能M行]有实幕樱比如斜着滑樱因此我就要事先判嘤舻拇笾乱D
					// 即，在水平方向上滑樱是在Q直方向上
					if (Math.abs(offsetX) > Math.abs(offsetY)) {// 水平方向上的移哟箪敦Q直方向上的移
																// t判定水平滑
						if (offsetX < -5) {// 什N不直接0呢，了p小`差
							// System.out.println("left");//
							// 至於怎N判嘧笥乙樱Mview的座司涂梢越Q}
							sweepLeft();
						} else if (offsetX > 5) {
							// System.out.println("right");
							sweepRight();
						}

					} else {// @就是Q直方向上的移恿
						if (offsetY < -5) {
							// System.out.println("up");
							sweepUp();
						} else if (offsetY > 5) {
							// System.out.println("down");
							sweepDown();
						}
					}
					break;
				}
				return true;
			}
		});
	}

	/**
	 * B化卡片的高等等
	 */
	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		// TODO Auto-generated method stub
		super.onSizeChanged(w, h, oldw, oldh);
		// 这里是设置每一个卡片的宽度，我们并没指定哪一种数据为宽，而是谁比较短，谁就是宽度，减10的目的是给屏幕留出10像素的距离来，除以4是我们的排列是4行4列
		int cardWidth = (Math.min(w, h) - 10) / 4;//
		addCards(cardWidth, cardWidth);// 我们的卡片设置成了正方形，
		startGame();
	}

	private void addCards(int cardWidth, int cardHeighth) {
		Card c;
		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				c = new Card(getContext());
				cardMap[x][y] = c;// 将卡片记录下来
				c.setNum(0);
				addView(c, cardWidth, cardHeighth);// 这个方法非常典型，经常使用
			}
			// 一般在输出时这里换行，真是时光荏苒呀，想象当时C语言的时候，泪崩
		}
	}

	private void startGame() {
		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				cardMap[x][y].setNum(0);
			}

		}
		addRandomNum();
		addRandomNum();
		addRandomNum();
		addRandomNum();
		addRandomNum();
		addRandomNum();
	}

	private void addRandomNum() {
		emptyPoints.clear();// 添加之前先清空
		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				if (cardMap[x][y].getNum() <= 0) {// 倘若是空点，若不是空点的话我们就不用再改变数字了 、

					emptyPoints.add(new Point(x, y));
				}
			}
		}
		Point p = emptyPoints
				.remove((int) (Math.random() * emptyPoints.size()));// 注意强制类型的转换，.random（）是产生0-1之间的数，此时先取整的话会造成置零的
		cardMap[p.x][p.y].setNum(Math.random() > 0.1 ? 2 : 4);
		// 情况
	}

	private void sweepLeft() {
		// 向左划的时候我们一行一行的扫，注意view的坐标与我们数学上的意识中有点相反
		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				for (int x1 = x + 1; x1 < 4; x1++) {
					if (cardMap[x1][y].getNum() > 0) {// 说明x1,y这里不是空的
						if (cardMap[x][y].getNum() <= 0) {// x,y这里是空的，因此我们把后面的值转移到前面来，视觉上就是数字块向左移动了
							cardMap[x][y].setNum(cardMap[x1][y].getNum());
							cardMap[x1][y].setNum(0);// 右边的清空
							x--;// 这一行已经换了一次，然后再重新遍历一次
							break;// break才是对的，真是，在这里磨了半天，
						} else if (cardMap[x1][y].getNum() == cardMap[x][y]
								.getNum()) {// 倘若后面的数字与前面的相同，就进行合并
							// else if(cardMap[x1][y].equals(cardMap[x][y])
							cardMap[x][y].setNum(cardMap[x][y].getNum()
									+ cardMap[x1][y].getNum());
							cardMap[x1][y].setNum(0);// 右边的清空
							break;
						}
					}

				}
			}
		}
	}

	private void sweepRight() {
		for (int y = 0; y < 4; y++) {
			for (int x = 3; x >= 0; x--) {
				for (int x1 = x - 1; x1 >= 0; x1--) {
					if (cardMap[x1][y].getNum() > 0) {// 说明x1,y这里不是空的
						if (cardMap[x][y].getNum() <= 0) {// x,y这里是空的，因此我们把后面的值转移到前面来，视觉上就是数字块向左移动了
							cardMap[x][y].setNum(cardMap[x1][y].getNum());
							cardMap[x1][y].setNum(0);// 右边的清空
							x++;// 这一行已经换了一次，然后再重新遍历一次
							break;// break才是对的，真是，在这里磨了半天，
						} else if (cardMap[x1][y].getNum() == cardMap[x][y]
								.getNum()) {// 倘若后面的数字与前面的相同，就进行合并
							// else if(cardMap[x1][y].equals(cardMap[x][y])
							cardMap[x][y].setNum(cardMap[x][y].getNum()
									+ cardMap[x1][y].getNum());
							cardMap[x1][y].setNum(0);// 右边的清空
							break;
						}
					}

				}
			}
		}
	}

	private void sweepUp() {
		
	}

	private void sweepDown() {
		for (int x = 0;  x < 4; x++) {
			for (int y= 0; y< 4; y++) {
				for (int y1 = y + 1; y1< 4; y1++) {
					if (cardMap[x][y1].getNum() > 0) {// 说明x1,y这里不是空的
						if (cardMap[x][y1].getNum() <= 0) {// x,y这里是空的，因此我们把后面的值转移到前面来，视觉上就是数字块向左移动了
							cardMap[x][y1].setNum(cardMap[x][y].getNum());
							cardMap[x][y].setNum(0);// 右边的清空
							y1++;// 这一行已经换了一次，然后再重新遍历一次
							break;// break才是对的，真是，在这里磨了半天，
						} else if (cardMap[x][y1].getNum() == cardMap[x][y]
								.getNum()) {// 倘若后面的数字与前面的相同，就进行合并
							// else if(cardMap[x1][y].equals(cardMap[x][y])
							cardMap[x][y1].setNum(cardMap[x][y1].getNum()
									+ cardMap[x][y].getNum());
							cardMap[x][y].setNum(0);// 右边的清空
							break;
						}
					}

				}
			}
		}
	}

	private Card[][] cardMap = new Card[4][4];
	private List<Point> emptyPoints = new ArrayList<Point>();// 说是为了让我们将数字存在里面方便取
}
